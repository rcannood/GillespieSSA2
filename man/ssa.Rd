% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ssa.R
\name{ssa}
\alias{ssa}
\title{Invoking the stochastic simulation algorithm}
\usage{
ssa(initial_state, propensity_funs, nu, final_time, params = NULL,
  method = ssa_direct(), census_interval = 0,
  stop_on_neg_state = TRUE, max_walltime = Inf,
  hardcode_params = FALSE, verbose = FALSE, console_interval = 1,
  use_vector_optimisation = FALSE)
}
\arguments{
\item{initial_state}{\code{[named numeric vector]} The initial state to start the simulation with.}

\item{propensity_funs}{\code{[character vector]} A character representation of the propensity functions, written in C++.}

\item{nu}{\code{[numeric matrix]} The changes in number of individuals in a state (rows) caused
by a single reaction (columns).}

\item{final_time}{\code{[numeric]} The final simulation time.}

\item{params}{\code{[named numeric vector]} Constant parameters to be used in the propensity functions.}

\item{method}{\code{[SSA]}] Which SSA algorithm to use. Must be one of: \code{\link[=ssa_direct]{ssa_direct()}},
\code{\link[=ssa_btl]{ssa_btl()}}, or \code{\link[=ssa_etl]{ssa_etl()}}.}

\item{census_interval}{\code{[numeric]} The approximate interval between recording the state of the system.
Setting this parameter to \code{0} will cause each state to be recorded, and
to \code{Inf} will cause only the end state to be recorded.}

\item{stop_on_neg_state}{\code{[logical]} Whether or not to stop the simulation when
the a negative value in the state has occured. This can occur, for instance, in the \code{\link[=ssa_etl]{ssa_etl()}}
method.}

\item{max_walltime}{\code{[numeric]} The maximum duration (in seconds) that the
simulation is allowed to run for before terminated.}

\item{hardcode_params}{\code{[logical]} Whether or not to hardcode the values of \code{params} in the compilation of the \code{propensity_funs}.
Setting this to \code{TRUE} will result in a minor sacrifice in accuracy for a minor increase in performance.}

\item{verbose}{\code{[logical]} If \code{TRUE}, intermediary information pertaining to the simulation will be displayed.}

\item{console_interval}{\code{[numeric]} The approximate interval between intermediary information outputs.}

\item{use_vector_optimisation}{\code{[logical]} An experimental optimisation. Do not use yet.}
}
\value{
Returns a list object with the following elements:
\itemize{
\item \code{time}: \code{[numeric]} Simulatiom time for each recorded timepoint.
\item \code{state}: \code{[numeric matrix]} The state values for each of the timepoints.
\item \code{propensity}: \code{[numeric matrix]} The propensity values for each of the timepoints.
\item \code{buffer}: \code{[numeric matrix]} The temporary calculation buffer used as part of the propensity functions.
}
}
\description{
Main interface function to the implemented \acronym{SSA} methods. Runs a
single realization of a predefined system. For a detailed explanation
on how to set up your first \acronym{SSA} system, check the vignette
available on \href{https://github.com/dynverse/fastgssa/tree/master/vignettes/preparing_a_run.md}{GitHub}
or using \code{vignette("preparing_a_run", package = "fastgssa")}.
}
\details{
Substantial improvements in speed and accuracy can be obtained by
adjusting the additional (and optional) \code{ssa} arguments. By default
\code{ssa} uses conservative parameters (o.a. \code{\link[=ssa_direct]{ssa_direct()}}) which prioritise
computational accuracy over computational speed.

Approximate methods (\code{\link[=ssa_etl]{ssa_etl()}} and \code{\link[=ssa_btl]{ssa_btl()}}) are not fool proof!
Some tweaking might be required for a stochastic model to run appropriately.
}
\examples{
initial_state <- c(x_prey = 1000, x_predators = 1000)
nu <- matrix(
  c(
    +1, -1, 0,
    0, +1, -1
  ),
  nrow = 2,
  byrow = TRUE,
  dimnames = list(
    c("x_prey", "x_predators"),
    c("p_prey_up", "p_predation", "p_pred_down")
  )
)
propensity_funs <- c(
  "p_prey_up = c1 * x_prey",
  "p_predation = c2 * x_prey * x_predators",
  "p_pred_down = c3 * x_predators"
)
params <- c(c1 = 10, c2 = 0.01, c3 = 10)

out <-
  ssa(
    initial_state = initial_state,
    propensity_funs = propensity_funs,
    nu = nu,
    params = params,
    method = ssa_direct(),
    final_time = 5,
    census_interval = .001,
    verbose = TRUE
  )
ssa_plot(out)

}
\seealso{
\link{fastgssa} for a high level explanation of the package
}
